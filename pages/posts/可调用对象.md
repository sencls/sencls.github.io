---
title: C++ å¯è°ƒç”¨å¯¹è±¡
date: 2026-02-12
updated: 2026-02-12
categories: C++
tags:
  - C++
  - å‡½æ•°æŒ‡é’ˆ
  - Lambda
  - ä»¿å‡½æ•°
---

# å¯è°ƒç”¨å¯¹è±¡

> æœ¬æ–‡ä»¶æ•´ç†äº† `lamd_function.cpp` ä¸­çš„æ³¨é‡Šå†…å®¹

---

## ç›®å½•

- [æ¦‚è¿°](#æ¦‚è¿°)
- [å‡½æ•°æŒ‡é’ˆ](#å‡½æ•°æŒ‡é’ˆ)
- [ä»¿å‡½æ•°ï¼ˆå‡½æ•°å¯¹è±¡ï¼‰](#ä»¿å‡½æ•°å‡½æ•°å¯¹è±¡)
- [Lambda è¡¨è¾¾å¼](#lambda-è¡¨è¾¾å¼)
- [std::function](#stdfunction)
- [std::bind](#stdbind)

---

## æ¦‚è¿°

C++ ä¸­çš„å¯è°ƒç”¨å¯¹è±¡åŒ…æ‹¬ï¼š

- **å‡½æ•°æŒ‡é’ˆ**
- **ä»¿å‡½æ•°**ï¼ˆå‡½æ•°å¯¹è±¡ï¼‰
- **Lambda è¡¨è¾¾å¼**
- **std::function**
- **std::bind**

---

## å‡½æ•°æŒ‡é’ˆ

### åŸºæœ¬ç”¨æ³•

```cpp
int (*p)(int, int);

int add(int a, int b) {
    return a + b;
}

p = add;               // ç­‰ä»·äº p = &add;
std::cout << (*p)(1, 2);  // ç­‰ä»·äº p(1, 2)
```

### ä¼˜ç¼ºç‚¹

| ä¼˜ç‚¹ | ç¼ºç‚¹ |
|:---|:---|
| ç®€å•ç›´è§‚ | ä¸èƒ½æ•è·ä¸Šä¸‹æ–‡ |
| é€‚åˆç®€å•çš„å›è°ƒå‡½æ•° | æŒ‡é’ˆçš„å£°æ˜å’Œä½¿ç”¨è¾ƒå¤æ‚ |

---

## ä»¿å‡½æ•°ï¼ˆå‡½æ•°å¯¹è±¡ï¼‰

ä»¿å‡½æ•°æ˜¯**é‡è½½äº† `operator()`** çš„ç±»æˆ–ç»“æ„ä½“ã€‚

### ç®€å•åº”ç”¨

```cpp
struct adder {
    int to_add;
    adder(int val) : to_add(val) {}
    int operator()(int x) {
        return x + to_add;
    }
};

adder a(2);
std::cout << a.to_add;  // è¾“å‡º: 2
int b = a(1);           // è°ƒç”¨ operator()
std::cout << b;         // è¾“å‡º: 3
```

### ä¼˜ç¼ºç‚¹

| ä¼˜ç‚¹ | è¯´æ˜ |
|:---|:---|
| **æºå¸¦çŠ¶æ€** | å¯ä»¥æ‹¥æœ‰å†…éƒ¨çŠ¶æ€ï¼Œé€šè¿‡æˆå‘˜å˜é‡å­˜å‚¨æ•°æ®ï¼Œè°ƒç”¨æ—¶å…·å¤‡ä¸Šä¸‹æ–‡ |
| **çµæ´»æ€§é«˜** | å¯ä»¥æ ¹æ®éœ€è¦æ·»åŠ æ›´å¤šçš„æˆå‘˜å‡½æ•°å’Œå˜é‡ï¼Œæ‹“å±•åŠŸèƒ½ |
| **æ€§èƒ½ä¼˜åŒ–** | ç¼–è¯‘å™¨å¯¹ä»¿å‡½æ•°ä¼˜åŒ–ï¼Œå†…è”å±•å¼€ |
| **ç±»å‹å®‰å…¨** | ä½¿ç”¨æ—¶ç¼–è¯‘æœŸé—´æ£€æŸ¥ |

### ä½¿ç”¨åœºæ™¯

- éœ€è¦æºå¸¦çŠ¶æ€æ—¶
- å¤æ‚æ“ä½œæ—¶ï¼ˆlambda éš¾ä»¥è¡¨è¾¾çš„å¤æ‚é€»è¾‘ï¼‰
- æ€§èƒ½å…³é”®åœºæ™¯

### ä¸ STL ç»“åˆä½¿ç”¨

```cpp
struct IsGreatThan {
    int threshold;
    IsGreatThan(int val) : threshold(val) {}
    bool operator()(int x) const {
        return x > threshold;
    }
};

IsGreatThan great(10);
std::vector<int> num = {1, 2, 10, 7};
auto it = std::find_if(num.begin(), num.end(), great);
if (it != num.end())
    std::cout << *it;
else
    std::cout << "None";
```

### æ³›å‹æ¯”è¾ƒå™¨

```cpp
template <typename T>
struct Compare {
    bool operator()(const T& a, const T& b) const {
        return a < b;
    }
};

std::vector<int> a = {1, 1, 1, 44565, 3, 7, 8, 312};
std::sort(a.begin(), a.end(), Compare<int>());
for (const auto &t : a) {
    std::cout << t << " ";
}
```

---

## Lambda è¡¨è¾¾å¼

### è¯­æ³•

```cpp
[capture](parameters) -> return_type {
    // å‡½æ•°ä½“
}
```

| éƒ¨åˆ† | è¯´æ˜ |
|:---|:---|
| **capture** | å‘å¤–æ•è·éœ€è¦çš„å˜é‡ï¼Œå€¼æ•è·ã€å¼•ç”¨æ•è·ã€æ··åˆæ•è· |
| **parameters** | å‚æ•°åˆ—è¡¨ |
| **return_type** | å¯ä»¥ä¸å†™ï¼ŒC++14 è‡ªåŠ¨æ¨å¯¼ |

### æ•è·æ–¹å¼

| æ•è·æ–¹å¼ | è¯´æ˜ |
|:---|:---|
| `[=]` | å€¼æ•è·æ‰€æœ‰å˜é‡ |
| `[&]` | å¼•ç”¨æ•è·æ‰€æœ‰å˜é‡ |
| `[=,&val]` | æ··åˆæ•è·ï¼šval å¼•ç”¨æ•è·ï¼Œå…¶ä»–å€¼æ•è· |
| `[&,val]` | æ··åˆæ•è·ï¼šval å€¼æ•è·ï¼Œå…¶ä»–å¼•ç”¨æ•è· |
| `[=name]` | åªæ”¶é›†æŒ‡å®šå˜é‡ï¼ˆä¸åŠ ç­‰å·ä¼šæ”¶é›†å‰é¢æ‰€æœ‰å˜é‡ï¼‰ |

### ç¤ºä¾‹ï¼šé€šè¿‡ erase ä¸ remove_if å®ç°ç›®æ ‡åˆ é™¤

```cpp
int threshold = 10;
std::vector<int> a = {1, 12, 111, 4, 3, 7, 8, 312};
a.erase(std::remove_if(a.begin(), a.end(),
                       [threshold](int n) -> bool {  // true æ»¡è¶³æ¡ä»¶åˆ é™¤
                           return n > threshold;
                       }),
        a.end());
```

### mutable å…³é”®å­—

`[]() mutable` å¯å˜ lambda å¯ä»¥è®©å€¼æ•è·çš„å˜é‡åœ¨å‡½æ•°å†…ä¿®æ”¹ï¼Œä½†ä½œç”¨åŸŸå¤–çš„å€¼ä¸ä¼šä¿®æ”¹ã€‚

### å‚æ•°ä½¿ç”¨ç¤ºä¾‹

```cpp
int a = 19;
int *temp = &a;
auto la = [temp](int x) -> void {
    *temp *= x;
};
la(2);
```

### åœ¨ç±»ä¸­ä½¿ç”¨

```cpp
class Precessor {
    int _threshold;

public:
    Precessor(int threshold) : _threshold(threshold) {}

    void process(std::vector<int> &data) {
        for (const auto &t : data)
            std::cout << t << ' ';
        std::cout << std::endl;

        data.erase(std::remove_if(data.begin(), data.end(),
                                  [this](int x) -> bool {
                                      return x <= _threshold;
                                  }),
                   data.end());

        for (const auto &t : data)
            std::cout << t << ' ';
    }
};

// ç±»å¤–ä½¿ç”¨ï¼ša æ˜¯ç±»çš„å˜é‡ï¼Œç”¨å¼•ç”¨æ•è·
auto dfun = [&a](int x) -> void {
    a.m(23, x);
};
```

### ä¼˜ç¼ºç‚¹

| ä¼˜ç‚¹ | è¯´æ˜ |
|:---|:---|
| **ç®€æ´** | ä»£ç ç®€æ´æ˜äº† |
| **çµæ´»** | å¯ä»¥æ•è·å¤–éƒ¨å˜é‡ |
| **æ€§èƒ½ä¼˜åŒ–** | ç¼–è¯‘å™¨å¯ä»¥ä¼˜åŒ– |
| **ä¸ STL æ— ç¼ç»“åˆ** | å¯ä»¥ç›´æ¥ç”¨äº STL ç®—æ³• |

---

## std::function

`std::function`ï¼ˆfunctional åº“ï¼‰æ˜¯ C++11 é€šç”¨çš„å¯è°ƒç”¨å¯¹è±¡å°è£…å™¨ï¼Œå¯ä»¥å°è£…ä»»ä½•å¯è°ƒç”¨å¯¹è±¡ï¼ŒåŒ…æ‹¬ï¼š

- æ™®é€šå‡½æ•°
- Lambda å‡½æ•°
- å‡½æ•°å¯¹è±¡
- ç»‘å®šè¡¨è¾¾å¼

### åŸºæœ¬ç”¨æ³•

```cpp
#include <functional>

// ç»‘å®šæ™®é€šå‡½æ•°
std::function<int(int, int)> callback = add;
std::cout << callback(1, 2) << std::endl;

// ç»‘å®šä»¿å‡½æ•°
A a;
std::function<int(int, int)> fun1 = a;
std::cout << fun1(1, 2) << std::endl;

// ç»‘å®š lambda å‡½æ•°
std::function<int(int)> fun2 = [](int x) -> int { return x; };
std::cout << fun2(3) << std::endl;

std::function<void()> fun3 = []() -> void {
    std::cout << "aaaaa" << std::endl;
};
```

### ç‰¹ç‚¹

| ç‰¹ç‚¹ | è¯´æ˜ |
|:---|:---|
| **å­˜å‚¨å„ç§å¯è°ƒç”¨å¯¹è±¡** | ç»Ÿä¸€çš„æ¥å£ |
| **æ”¯æŒåŠ¨æ€æ”¹å˜** | å¯ä»¥é‡æ–°èµ‹å€¼ |
| **é¢‘ç¹è°ƒç”¨æ—¶æœ‰å¼€é”€** | ç›¸æ¯”ç›´æ¥è°ƒç”¨æœ‰é¢å¤–æˆæœ¬ |

### ä½¿ç”¨åœºæ™¯

#### 1. å›è°ƒå‡½æ•°

```cpp
using CallBack = std::function<void(int)>;

void triggerEvent(CallBack cb, int value) {
    cb(value);
}

// ä½¿ç”¨ lambda
triggerEvent([](int x) -> void {
    std::cout << "aaa" << ' ' << x << std::endl;
}, 3);

// ä½¿ç”¨ä»¿å‡½æ•°
struct Printer {
    void operator()(int x) const {
        std::cout << "è°ƒç”¨" << x << std::endl;
    }
} printt;

triggerEvent(printt, 4);
```

#### 2. å­˜å‚¨ä¸è°ƒç”¨ä¸åŒç±»å‹çš„å¯è°ƒç”¨å¯¹è±¡

```cpp
// ä½¿ç”¨å®¹å™¨ç±»æ¥å­˜å‚¨
// æ¯”å¦‚ vector<std::function<int(int,int)>>, map ä¹‹ç±»
// emplace_back æ¯” push_back å°‘ä¸€æ¬¡æ„é€ ï¼Œæ›´èŠ‚çœ
```

---

## std::bind

`std::bind()` åœ¨ functional åº“ä¸­ï¼Œå¯ä»¥ç»‘å®šå¯¹è±¡å‡½æ•°ï¼ŒåŒæ—¶æ§åˆ¶ä¸€å®šçš„å‚æ•°ï¼Œå¾…å®šå‚æ•°ä½¿ç”¨ `std::placeholders` å ä½ã€‚

### åŸºæœ¬ç”¨æ³•

```cpp
// bind(ç»‘å®šå¯¹è±¡ï¼Œå‚æ•°1ï¼Œå‚æ•°2)
auto neew = std::bind(add, std::placeholders::_1, 2);
// ç›¸å½“äº add(x, 2)
```

### ç»‘å®šç±»æˆå‘˜å‡½æ•°

```cpp
// ç±»æˆå‘˜å‡½æ•°éœ€è¦å–åœ°å€ï¼Œç±»å¯¹è±¡åšç¬¬äºŒä¸ªå‚æ•°ï¼Œä¹Ÿå–åœ°å€
auto neew = std::bind(&A::m, &a, std::placeholders::_1, 2);

// æ³¨æ„ï¼šé™æ€æˆå‘˜å‡½æ•°ä¸éœ€è¦ç¬¬äºŒå‚æ•°
```

### å ä½ç¬¦

```cpp
std::placeholders::_1  // ç¬¬ä¸€ä¸ªå‚æ•°
std::placeholders::_2  // ç¬¬äºŒä¸ªå‚æ•°
// ... ä¾æ­¤ç±»æ¨
```

### å®Œæ•´ç¤ºä¾‹

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>

class A {
public:
    A() : res(0) {}
    int res;
    int m(int a, int b) {
        res = a * b;
        return res;
    }
};

int main() {
    A a;
    auto neew = std::bind(&A::m, &a, std::placeholders::_1, 2);
    auto dfun = [&a](int x) -> int {
        return a.m(23, x);
    };
    std::cout << neew(3) << ' ' << dfun(1);

    return 0;
}
```

---

> æ•´ç†è€…ï¼šè•¾å§† ğŸ’™
