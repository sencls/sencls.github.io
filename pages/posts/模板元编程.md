---
title: C++ æ¨¡æ¿å…ƒç¼–ç¨‹
date: 2026-02-12
updated: 2026-02-12
categories: C++
tags:
  - C++
  - æ¨¡æ¿
  - å…ƒç¼–ç¨‹
  - ç¼–è¯‘æœŸè®¡ç®—
---

# æ¨¡æ¿å…ƒç¼–ç¨‹

> æœ¬æ–‡ä»¶æ•´ç†äº† `Template_Meta.cpp` ä¸­çš„æ³¨é‡Šå†…å®¹

---

## æ¦‚å¿µ

**æ¨¡æ¿å…ƒç¼–ç¨‹**ï¼ˆTemplate Metaprogramming, TMPï¼‰æ˜¯åœ¨ç¼–è¯‘æœŸé€šè¿‡æ¨¡æ¿æœºåˆ¶è¿›è¡Œä»£ç ç”Ÿæˆä¸è®¡ç®—çš„æŠ€æœ¯ï¼Œåˆ©ç”¨ç¼–è¯‘å™¨çš„æ¨¡æ¿å®ä¾‹åŒ–æœºåˆ¶ï¼Œåœ¨ç¼–è¯‘æœŸæ‰§è¡Œä»£ç é€»è¾‘ï¼Œæé«˜æ€§èƒ½å’Œçµæ´»æ€§ã€‚

## ä¼˜ç‚¹

| ä¼˜ç‚¹ | è¯´æ˜ |
|:---|:---|
| **æé«˜ä»£ç çš„å¯é‡å¤æ€§ä¸æ³›åŒ–èƒ½åŠ›** | ä¸€æ¬¡ç¼–å†™ï¼Œå¤šå¤„ä½¿ç”¨ |
| **å‡å°è¿è¡Œæ—¶å¼€é”€** | è®¡ç®—åœ¨ç¼–è¯‘æœŸå®Œæˆ |
| **å®ç°ç±»å‹å®‰å…¨çš„é«˜çº§æŠ½è±¡** | ç¼–è¯‘æœŸç±»å‹æ£€æŸ¥ |

## åŸºç¡€

- **æ¨¡æ¿ç‰¹åŒ–**
- **é€’å½’æ¨¡æ¿**

---

## ç¤ºä¾‹1ï¼šç¼–è¯‘æœŸè®¡ç®—é˜¶ä¹˜

### ä»£ç å®ç°

```cpp
template <int N>
struct Factorial {
    // æ”¹ä¸º inline static const int value = ... å°±ä¸éœ€è¦ç±»å¤–å®šä¹‰ï¼Œæ¥é˜²æ­¢å–å†…å­˜å´©
    static const int value = N * Factorial<N - 1>::value;
};

// ç‰¹åŒ–åŸºç¡€æƒ…å†µ
template <>
struct Factorial<0> {
    static const int value = 1;
};

// ä¸º Factorial<0>::value æä¾›å®šä¹‰ï¼Œä½¿å…¶å¯ä»¥å–åœ°å€
template <int N>
const int Factorial<N>::value;

template <>
const int Factorial<0>::value;  // é™æ€ç¼–è¯‘ä¼šæŠ¥é”™ï¼Œä½†ä¸å½±å“è¿è¡Œ
```

### ä½¿ç”¨

```cpp
// ç¼–è¯‘æœŸè®¡ç®—ï¼Œè¿è¡Œæ—¶ç›´æ¥ä½¿ç”¨ç»“æœ
constexpr int result = Factorial<5>::value;  // result = 120
```

### å·¥ä½œåŸç†

```
Factorial<5>::value
= 5 * Factorial<4>::value
= 5 * (4 * Factorial<3>::value)
= 5 * (4 * (3 * Factorial<2>::value))
= 5 * (4 * (3 * (2 * Factorial<1>::value)))
= 5 * (4 * (3 * (2 * (1 * Factorial<0>::value))))
= 5 * (4 * (3 * (2 * (1 * 1))))
= 120
```

---

## ç¤ºä¾‹2ï¼šåˆ¤æ–­ç±»å‹æ˜¯å¦å¯ç›¸åŠ 

### ä»£ç å®ç°

```cpp
#include <type_traits>

// é»˜è®¤æƒ…å†µï¼šä¸å¯ç›¸åŠ 
template <typename T, typename = void>
struct is_addable : std::false_type {};

// ç‰¹åŒ–ï¼šå¯ä»¥ç›¸åŠ 
template <typename T>
struct is_addable<T,
    decltype(void(std::declval<T>() + std::declval<T>()))
> : std::true_type {};
```

### å…³é”®æŠ€æœ¯

**std::declval**ï¼šä¸åˆ›å»ºå®é™…å¯¹è±¡ï¼Œä½†è¿”å›ä¸€ä¸ªå¯¹åº”ç±»å‹çš„å³å€¼å¼•ç”¨

```cpp
// declval çš„ä½œç”¨
// std::declval<T>() è¿”å› T&&
// ç”¨äºåœ¨ä¸åˆ›å»ºå¯¹è±¡çš„æƒ…å†µä¸‹ï¼Œæ¨¡æ‹Ÿè°ƒç”¨æˆå‘˜å‡½æ•°æˆ–æ“ä½œç¬¦
```

### ä½¿ç”¨

```cpp
static_assert(is_addable<int>::value, "int should be addable");
static_assert(!is_addable<void>::value, "void should not be addable");
```

---

## ç¤ºä¾‹3ï¼šç±»å‹åˆ—è¡¨ä¸ç´¢å¼•è®¿é—®

### ç±»å‹åˆ—è¡¨å®šä¹‰

```cpp
template <typename... Ts>
struct typelist {};
```

### æŒ‰ç´¢å¼•è·å–ç±»å‹

```cpp
template <typename List, std::size_t N>
struct TypeAt {};

// åŸºç¡€æƒ…å†µï¼šç´¢å¼•ä¸º 0
template <typename Head, typename... Tail>
struct TypeAt<typelist<Head, Tail...>, 0> {
    using type = Head;
};

// é€’å½’æƒ…å†µï¼šç´¢å¼•ä¸ä¸º 0
template <typename Head, typename... Tail, std::size_t N>
struct TypeAt<typelist<Head, Tail...>, N> {
    using type = typename TypeAt<typelist<Tail...>, N - 1>::type;
};
```

### ä½¿ç”¨

```cpp
using list = typelist<int, double, char>;
using third = TypeAt<list, 1>::type;  // third = double

// è¾“å‡ºç±»å‹åç§°
std::cout << typeid(third).name() << std::endl;
```

### å·¥ä½œåŸç†

```
typelist<int, double, char>

TypeAt<list, 0>::type  â†’ int
TypeAt<list, 1>::type  â†’ double
TypeAt<list, 2>::type  â†’ char
```

---

## é«˜çº§æŠ€å·§

### constexpr å˜é‡ï¼ˆC++11ï¼‰

```cpp
// ä½¿ç”¨ constexpr æ›¿ä»£ static const
template <int N>
struct Factorial {
    static constexpr int value = N * Factorial<N - 1>::value;
};

template <>
struct Factorial<0> {
    static constexpr int value = 1;
};

// ä¸éœ€è¦ç±»å¤–å®šä¹‰ï¼Œå¯ä»¥ç›´æ¥å–åœ°å€
constexpr auto val = Factorial<5>::value;  // å®Œå…¨åˆæ³•
```

### inline å˜é‡ï¼ˆC++17ï¼‰

```cpp
// C++17 å¼•å…¥ inline å˜é‡
template <int N>
struct Factorial {
    inline static const int value = N * Factorial<N - 1>::value;
};

// ä¹Ÿä¸éœ€è¦ç±»å¤–å®šä¹‰
```

### å˜å‚æ¨¡æ¿ + æŠ˜å è¡¨è¾¾å¼ï¼ˆC++17ï¼‰

```cpp
#include <iostream>

// æ‰“å°æ‰€æœ‰å‚æ•°
template <typename... Args>
void print_all(const Args &...args) {
    ((std::cout << args << " "), ...);  // C++17 æŠ˜å è¡¨è¾¾å¼
}

// æ±‚å’Œ
template <typename... Args>
auto sum_all(const Args &...args) {
    return (args + ...);  // C++17 æŠ˜å è¡¨è¾¾å¼
}

// ä½¿ç”¨
// print_all(1, 2.5, "hello");
// sum_all(1, 2, 3, 4);  // è¿”å› 10
```

---

## å¸¸ç”¨ç±»å‹ç‰¹æ€§

```cpp
#include <type_traits>

// åˆ¤æ–­ç±»å‹
std::is_integral<T>::value      // æ˜¯å¦æ•´æ•°ç±»å‹
std::is_floating_point<T>::value // æ˜¯å¦æµ®ç‚¹ç±»å‹
std::is_pointer<T>::value       // æ˜¯å¦æŒ‡é’ˆç±»å‹
std::is_reference<T>::value     // æ˜¯å¦å¼•ç”¨ç±»å‹
std::is_const<T>::value         // æ˜¯å¦ const ç±»å‹
std::is_same<T, U>::value       // T å’Œ U æ˜¯å¦ç›¸åŒç±»å‹

// ç±»å‹è½¬æ¢
std::remove_reference_t<T>      // ç§»é™¤å¼•ç”¨
std::remove_const_t<T>          // ç§»é™¤ const
std::add_pointer_t<T>           // æ·»åŠ æŒ‡é’ˆ
std::make_unsigned_t<T>         // è½¬æ¢ä¸ºæ— ç¬¦å·ç±»å‹

// ç±»å‹æ“ä½œ
std::enable_if<condition, T>::type  // æ¡ä»¶æ»¡è¶³æ—¶ç±»å‹ä¸º Tï¼Œå¦åˆ™æ—  type æˆå‘˜
std::decay_t<T>                     // è¡°é€€ç±»å‹ï¼ˆæ•°ç»„è½¬æŒ‡é’ˆï¼Œå‡½æ•°è½¬å‡½æ•°æŒ‡é’ˆï¼Œç§»é™¤ cvï¼‰
```

---

## é™æ€æ–­è¨€

```cpp
// ç¼–è¯‘æœŸæ–­è¨€
static_assert(condition, "error message");

// ç¤ºä¾‹
template <typename T>
void check() {
    static_assert(std::is_integral<T>::value, "T must be integral");
}

// check<int>();   // OK
// check<double>(); // ç¼–è¯‘é”™è¯¯ï¼šT must be integral
```

---

## æ€»ç»“

| æŠ€æœ¯ç‰ˆæœ¬ | ç‰¹æ€§ | è¯´æ˜ |
|:---|:---|:---|
| **C++98** | æ¨¡æ¿ç‰¹åŒ–ã€é€’å½’æ¨¡æ¿ | åŸºç¡€ TMP |
| **C++11** | constexprã€å˜å‚æ¨¡æ¿ã€type_traits | å¢å¼º TMP |
| **C++14** | constexpr å‡½æ•°æ”¾å®½ | æ›´çµæ´»çš„ç¼–è¯‘æœŸè®¡ç®— |
| **C++17** | æŠ˜å è¡¨è¾¾å¼ã€if constexpr | ç®€åŒ–å‚æ•°åŒ…å¤„ç† |
| **C++20** | Concept | æ›´æ¸…æ™°çš„çº¦æŸ |

### ç¼–è¯‘æœŸ vs è¿è¡ŒæœŸ

| ç‰¹æ€§ | ç¼–è¯‘æœŸ | è¿è¡ŒæœŸ |
|:---|:---|:---|
| **è®¡ç®—æ—¶é—´** | ç¼–è¯‘æ—¶ | è¿è¡Œæ—¶ |
| **æ€§èƒ½å¼€é”€** | æ—  | æœ‰ |
| **çµæ´»æ€§** | å—é™ | é«˜ |
| **è°ƒè¯•éš¾åº¦** | é«˜ | ä½ |

---

> æ•´ç†è€…ï¼šè•¾å§† ğŸ’™
