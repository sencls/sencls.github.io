---
title: C++ æ¨¡æ¿ç‰¹åŒ–
date: 2026-02-12
updated: 2026-02-12
categories: C++
tags:
  - C++
  - æ¨¡æ¿
  - ç‰¹åŒ–
  - SFINAE
---

# æ¨¡æ¿ç‰¹åŒ–

> æœ¬æ–‡ä»¶æ•´ç†äº† `model.cpp` ä¸­çš„æ³¨é‡Šå†…å®¹

---

## ç›®å½•

- [æ¨¡æ¿æ¨¡æ¿å‚æ•°](#æ¨¡æ¿æ¨¡æ¿å‚æ•°)
- [æ¨¡æ¿ç‰¹åŒ–](#æ¨¡æ¿ç‰¹åŒ–)
- [å˜å‚æ¨¡æ¿](#å˜å‚æ¨¡æ¿)
- [SFINAE](#sfinae)
- [C++20 Concept](#c20-concept)

---

## æ¨¡æ¿æ¨¡æ¿å‚æ•°

### åŸºæœ¬æ¦‚å¿µ

æ¨¡æ¿æ¨¡æ¿å‚æ•°æ˜¯æŒ‡æ¨¡æ¿å‚æ•°æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªæ¨¡æ¿ã€‚

### ç¤ºä¾‹

```cpp
template <template <typename, typename> class node, typename R>
class add {
    void print(const node<R, std::allocator<R>> &c) {
        for (auto &t : c) {
            std::cout << t << std::endl;
        }
    }
};

add<std::vector, int> ma;
```

---

## æ¨¡æ¿ç‰¹åŒ–

### ç±»å‹

1. **å…¨ç‰¹åŒ–** (Full Specialization)
2. **åç‰¹åŒ–** (Partial Specialization)

**æ³¨æ„ï¼š** å‡½æ•°åªèƒ½å…¨ç‰¹åŒ–

### ç¼–è¯‘å™¨ä¼˜å…ˆçº§

```
åç‰¹åŒ– > å…¨ç‰¹åŒ– > é€šç”¨æ¨¡æ¿
```

### ç¤ºä¾‹ä»£ç 

```cpp
// é€šç”¨æ¨¡æ¿
template <typename A, typename B>
class text {
public:
    void print() {
        std::cout << "æˆ‘ä¸€æ ·";
    }
};

// å…¨ç‰¹åŒ–
template <>
class text<std::string, int> {
public:
    void print() {
        std::cout << "æˆ‘ä¸ä¸€æ ·";
    }
};

// åç‰¹åŒ–
template <typename A>
class text<A, int*> {
public:
    void print() {
        std::cout << "æˆ‘ä¸ä¸€æ ·";
    }
};

// å‡½æ•°ç‰¹åŒ–ï¼ˆåªèƒ½å…¨ç‰¹åŒ–ï¼‰
template<typename T>
void print(const T& tri) {}

template<>
void print<int*>(int* const& value) {}
```

---

## å˜å‚æ¨¡æ¿

ä½¿ç”¨å‚æ•°åŒ…ï¼Œé€šè¿‡ `...` è¯­æ³•æ¥è¡¨ç¤ºã€‚

### åŸºæœ¬è¯­æ³•

```cpp
template <typename... Args>
class as {};

template <typename T, typename... Args>
void myfun(T first, Args... args) {
    std::cout << first;
}
```

### é€’å½’å±•å¼€

```cpp
// åŸºç¡€æƒ…å†µ
void printl() {
    std::cout << "all";
}

// é€’å½’æƒ…å†µ
template <typename A, typename... Args>
void printl(const A &first, const Args &...args) {
    std::cout << first << " ";
    printl(args...);  // é€’å½’è°ƒç”¨
}

// ä½¿ç”¨ç¤ºä¾‹
// int a = 1, b = 1, c = 1, d = 1, e = 1, f = 1;
// printl(a, b, c, d, e, f);
```

---

## C++17 æŠ˜å è¡¨è¾¾å¼

### ä¸€å…ƒæŠ˜å 

å¯¹å†…éƒ¨å‚æ•°ä½¿ç”¨ä¸€ä¸ªä¸€å…ƒæ“ä½œç¬¦ï¼ˆä¸å¸¸ç”¨ï¼‰

```cpp
// è¯­æ³•
(op ... pack)
(pack ... op)

// ç¤ºä¾‹
template <typename... Args>
bool all_true(const Args &...args) {
    return (!args && ...);  // å–éï¼Œå†ä¸ï¼›(!a) && (!b) && ...
}
```

### äºŒå…ƒæŠ˜å 

ä½¿ç”¨äºŒå…ƒæ“ä½œç¬¦

| ç±»å‹ | è¯­æ³• | ç»“åˆæ–¹å‘ |
|:---|:---|:---|
| **å·¦æŠ˜å ** | `(init op ... op pack)` | ä»å·¦åˆ°å³ |
| **å³æŠ˜å ** | `(pack op ... op init op ...)` | ä»å³åˆ°å·¦ |

#### ç¤ºä¾‹ï¼šæ±‚å’Œ

```cpp
// å·¦æŠ˜å 
template <typename... Args>
auto sum_left(const Args&... args) -> decltype((args + ...)) {
    return (args + ...);
}

// å³æŠ˜å 
template <typename... Args>
auto sum_right(const Args &...args) -> decltype((... + args)) {
    return (... + args);
}
```

#### ç¤ºä¾‹ï¼šæ±‚æœ€å¤§å€¼

```cpp
template <typename... Args, typename T>
auto maxn(const T &t, const Args &...args) -> decltype(std::max(t, (args, ...))) {
    return std::max(t, (args, ...));
}
```

#### ç¤ºä¾‹ï¼šæ‰“å°

```cpp
template <typename... Args>
void print(const Args &...args) {
    // æ–¹å¼1ï¼šé€—å·æŠ˜å 
    ((std::cout << args), ...);

    // æ–¹å¼2ï¼šä½¿ç”¨ <<
    // (std::cout << ... << args);
}
```

---

## SFINAE

### æ¦‚å¿µ

**S**ubstitution **F**ailure **I**s **N**ot **A**n **E**rrorï¼ˆæ›¿æ¢å¤±è´¥ä¸æ˜¯é”™è¯¯ï¼‰

ç¼–è¯‘å™¨å®ä¾‹åŒ–æ—¶ï¼Œåœ¨æ›¿æ¢æ¨¡æ¿å‚æ•°æ—¶å¤±è´¥ï¼Œä¸ä¼šå°†å…¶è§†ä½œç¼–è¯‘é”™è¯¯ï¼Œè€Œæ˜¯å¯»æ‰¾å…¶ä»–å¯èƒ½çš„æ¨¡æ¿æˆ–è€…é‡è½½ã€‚

### åº”ç”¨åœºæ™¯

1. **å‡½æ•°é‡è½½é€‰æ‹©**
2. **ç±»å‹ç‰¹æ€§æ£€æµ‹**
3. **æ¡ä»¶ç¼–è¯‘**

### ä½¿ç”¨ enable_if

```cpp
#include <type_traits>

// å½“ T æ˜¯æ•´æ•°ç±»å‹æ—¶å¯ç”¨
template <typename T>
typename std::enable_if<std::is_integral<T>::value, void>::type
print_type(T value) {
    std::cout << "int " << std::endl;
}

// å½“ T æ˜¯ const char* æ—¶å¯ç”¨
template <typename T>
typename std::enable_if<std::is_same<T, const char*>::value, void>::type
print_type(T value) {
    std::cout << "const char* " << std::endl;
}

// åˆ¤æ–­æ˜¯å¦æŒ‡é’ˆ
// std::is_pointer<T>::value
```

### åˆ¤æ–­ç±»æ˜¯å¦æœ‰æŸä¸ªæˆå‘˜

```cpp
template <typename T>
class has_foo {
private:
    typedef char yes[1];
    typedef char no[2];

    // U::* æ˜¯ U çš„æˆå‘˜å‡½æ•°æŒ‡é’ˆ
    template <typename U, void (U::*)()>
    struct SFINAE {};

    template <typename U>
    static yes &test(SFINAE<U, &U::foo> *);

    template <typename U>
    static no &test(...);  // ... æŒ‡ä»»æ„å‚æ•°

public:
    static constexpr bool value = sizeof(test<T>(0)) == sizeof(yes);
};

// ä½¿ç”¨
template <typename T>
typename std::enable_if<has_foo<T>::value, void>::type
call_foo(T &obj) {
    obj.foo();
    std::cout << "foo()" << std::endl;
}

class Withfoo {
public:
    void foo() { std::cout << "has\n"; }
};

class nofoo {
    // æ²¡æœ‰ foo æˆå‘˜
};
```

### æ£€æŸ¥ç±»å‹æ˜¯å¦æœ‰ value_type

```cpp
template <typename T, typename = void>
struct has_non_void_value_type : std::false_type {};

template <typename T>
struct has_non_void_value_type<T,
    std::enable_if_t<!std::is_void_v<typename T::value_type>>
> : std::true_type {};

// æ ¹æ® has_non_void_value_type çš„å€¼è¿›è¡Œç‰¹åŒ–
template <typename T, bool HasValueType = has_non_void_value_type<T>::value>
struct TypePrint {};

// T æœ‰ value_type æˆå‘˜
template <typename T>
struct TypePrint<T, true> {
    // æ˜¾å¼æ·»åŠ  typename æ˜¯ä¸ºäº†å‘Šè¯‰ç¼–è¯‘å™¨è¿™æ˜¯ç±»å‹ï¼Œè€Œä¸æ˜¯å¯¹è±¡
    // T::value_type -> T çš„ç±»å‹ï¼Œä¾‹å¦‚ vector<int>::value_type = int
    static void print() {
        std::cout << "T has a member type value_type";
    }
};

// T æ²¡æœ‰ value_type æˆå‘˜
template <typename T>
struct TypePrint<T, false> {
    static void print() {
        std::cout << "no type";
    }
};

// ä½¿ç”¨ç¤ºä¾‹
struct Withint {
    using value_type = int;
};

struct noint {
    // æ²¡æœ‰ value_type
};

// TypePrint<Withint>::print();  // è¾“å‡º: T has a member type value_type
// TypePrint<noint>::print();    // è¾“å‡º: no type
```

---

## C++20 Concept

### æ¦‚å¿µ

Concept æ˜¯ C++20 å¼•å…¥çš„çº¦æŸæ¨¡æ¿å‚æ•°çš„æœºåˆ¶ï¼Œä½¿æ¨¡æ¿å…ƒç¼–ç¨‹æ›´åŠ ç›´è§‚å’Œå®‰å…¨ã€‚

### åŸºæœ¬è¯­æ³•

```cpp
template <typename T>
concept ConceptName = è¦æ±‚;
```

### ç¤ºä¾‹1ï¼šåŸºæœ¬ä½¿ç”¨

```cpp
#include <concepts>

// å®šä¹‰ concept
template <typename T>
concept Integral = std::is_integral_v<T>;

// ä½¿ç”¨ concept çº¦æŸæ¨¡æ¿å‚æ•°
template <Integral T>
void print(T a) {
    std::cout << "integral: " << a << std::endl;
}

// æˆ–ä½¿ç”¨ requires
template <typename T>
requires Integral<T>
void print(T a) {
    std::cout << "integral: " << a << std::endl;
}
```

### ç¤ºä¾‹2ï¼šå¤æ‚çº¦æŸ

```cpp
// å®šä¹‰å¯æ‰“å°çš„æ¦‚å¿µ
template <typename T>
concept printable = requires(T a) {
    { std::cout << a } -> std::same_as<std::ostream &>;
};

// ä½¿ç”¨
template <printable T>
void print(T a) {
    std::cout << a << std::endl;
}
```

### requires è¡¨è¾¾å¼

```cpp
// requires æ­é…ä½¿ç”¨
// concept é™å®šæ¡ä»¶ï¼Œrequires æ’é™¤æ¡ä»¶

template <typename T>
concept Addable = requires(T a, T b) {
    { a + b } -> std::convertible_to<T>;
};

template <typename T>
requires Addable<T>
T add(T a, T b) {
    return a + b;
}
```

### å¯¹æ¯” SFINAE

| ç‰¹æ€§ | SFINAE | Concept (C++20) |
|:---|:---|:---|
| **å¯è¯»æ€§** | è¾ƒå·® | æ›´å¥½ |
| **é”™è¯¯ä¿¡æ¯** | éš¾ä»¥ç†è§£ | æ¸…æ™°æ˜ç¡® |
| **ç¼–å†™éš¾åº¦** | è¾ƒé«˜ | è¾ƒä½ |
| **ç¼–è¯‘å™¨æ”¯æŒ** | C++11+ | C++20+ |

---

## æ€»ç»“

| æŠ€æœ¯ | å¼•å…¥ç‰ˆæœ¬ | ä¸»è¦ç”¨é€” |
|:---|:---:|:---|
| **æ¨¡æ¿ç‰¹åŒ–** | C++98 | ä¸ºç‰¹å®šç±»å‹æä¾›ç‰¹æ®Šå®ç° |
| **å˜å‚æ¨¡æ¿** | C++11 | æ¥å—å¯å˜æ•°é‡çš„æ¨¡æ¿å‚æ•° |
| **æŠ˜å è¡¨è¾¾å¼** | C++17 | ç®€åŒ–å‚æ•°åŒ…å±•å¼€ |
| **SFINAE** | C++11 | ç±»å‹ç‰¹æ€§æ£€æµ‹ã€å‡½æ•°é‡è½½é€‰æ‹© |
| **Concept** | C++20 | çº¦æŸæ¨¡æ¿å‚æ•°ï¼Œæé«˜å¯è¯»æ€§ |

---

> æ•´ç†è€…ï¼šè•¾å§† ğŸ’™
