---
title: C++ å†…å­˜ç®¡ç†
date: 2026-02-12
updated: 2026-02-12
categories: C++
tags:
  - C++
  - å†…å­˜ç®¡ç†
  - æ™ºèƒ½æŒ‡é’ˆ
---

# å†…å­˜ç®¡ç†

> æœ¬æ–‡ä»¶æ•´ç†äº† `memory assistance.cpp` ä¸­çš„æ³¨é‡Šå†…å®¹

---

## ç›®å½•

- [C é£æ ¼å†…å­˜ç®¡ç†](#c-é£æ ¼å†…å­˜ç®¡ç†)
- [C++ é£æ ¼å†…å­˜ç®¡ç†](#c-é£æ ¼å†…å­˜ç®¡ç†-1)
- [malloc/free ä¸ new/delete çš„åŒºåˆ«](#mallocfree-ä¸-newdelete-çš„åŒºåˆ«)
- [C çš„ realloc](#c-çš„-realloc)
- [ç®€å•å®ç°åŠ¨æ€æ•°ç»„](#ç®€å•å®ç°åŠ¨æ€æ•°ç»„)
- [ç®€å•è®¤è¯†å†…å­˜æ± ](#ç®€å•è®¤è¯†å†…å­˜æ± )
- [é¿å…å†…å­˜æ³„æ¼](#é¿å…å†…å­˜æ³„æ¼)
- [æ™ºèƒ½æŒ‡é’ˆ](#æ™ºèƒ½æŒ‡é’ˆ)
- [å°ç»ƒä¹ ](#å°ç»ƒä¹ )

---

## C é£æ ¼å†…å­˜ç®¡ç†

### å‡½æ•°å£°æ˜

```cpp
void *malloc(size_t size);  // è¿”å›ä¸‡èƒ½æŒ‡é’ˆï¼Œsizeæ˜¯å¼€è¾Ÿçš„å­—èŠ‚æ•°ï¼Œmallocåœ¨äºå †ä¸Šåˆ†é…
void free(void *ptr);       // é‡Šæ”¾åŸæ¥ç”±mallocï¼Œcallocï¼Œreallocåˆ†é…çš„å†…å­˜
```

### åŸºæœ¬ç”¨æ³•

```cpp
int *p = (int *)malloc(sizeof(int));  // mallocè¿”å›å€¼æ˜¯void* æ•…å¼ºè½¬
if (p == nullptr) {
    std::cerr << "Memory allocation failed" << std::endl;
    return -1;
}
*p = 42;
std::cout << *p << std::endl;
free(p);
```

### æ³¨æ„äº‹é¡¹

- `malloc` åªå¼€è¾Ÿå†…å­˜ï¼Œå†…å®¹ä¸å®šï¼Œå¦‚æœæ˜¯ç±»çš„è¯ï¼Œ**ä¸è°ƒç”¨æ„é€ å‡½æ•°**
- `malloc` åªèƒ½ä¸ `free` æ­é…

### å¼€è¾Ÿæ•°ç»„

```cpp
// malloc(5 * sizeof(int)) == int[5]
int *arr_p = (int *)(malloc(5 * sizeof(int)));
if (arr_p == nullptr) {
    std::cerr << "memory failed" << std::endl;
    return -1;
}

for (size_t i = 0; i < 5; i++) {
    arr_p[i] = i * 2;  // ç­‰ä»·äº *(arr_p + i) = i * 2;
}

for (size_t i = 0; i < 5; i++) {
    std::cout << arr_p[i] << std::endl;
}
free(arr_p);
```

---

## C++ é£æ ¼å†…å­˜ç®¡ç†

### åŸºæœ¬ç”¨æ³•

```cpp
new/delete;  // ç›´æ¥è°ƒç”¨æ„é€ å‡½æ•°
```

### å¼€è¾Ÿæ•°ç»„

```cpp
new type[size];           // åŸºæœ¬ç±»å‹æ•°ç»„
new student[2] {{},{}};   // ç±»ç±»å‹æ•°ç»„
delete[] arr;             // é‡Šæ”¾æ•°ç»„éœ€è¦åŠ  []
```

### ä¸æŠ›å¼‚å¸¸çš„ new

```cpp
new(std::nothrow) type  // ä¸æŠ›å‡ºå¼‚å¸¸ï¼Œç›´æ¥ä»¤å…¶è¿”å›nullptr
// éœ€è¦ #include<new>
```

---

## malloc/free ä¸ new/delete çš„åŒºåˆ«

| ç‰¹æ€§ | malloc/free | new/delete |
|:---|:---|:---|
| **è¿”å›ç±»å‹** | `void*` | ç±»å‹æŒ‡é’ˆ |
| **æ„é€ /ææ„** | ä¸è°ƒç”¨æ„é€ /ææ„å‡½æ•° | è°ƒç”¨æ„é€ /ææ„å‡½æ•° |
| **åˆ†é…å¤±è´¥** | è¿”å› `nullptr` | é»˜è®¤æŠ›å‡º `std::bad_alloc` |

---

## C çš„ realloc

```cpp
void* realloc(void* ptr, size_t new_size)  // å¯¹å†…å­˜é‡æ–°åˆ†é…
```

---

## ç®€å•å®ç°åŠ¨æ€æ•°ç»„

```cpp
class dynamicArray {
    size_t size;
    size_t capacity;
    int *data;

    void resize(size_t num) {
        int *temp = (int *)realloc(data, num * sizeof(int));
        if (temp == nullptr) {
            throw std::bad_alloc{};
        }
        data = temp;
        capacity = num;
    }

public:
    dynamicArray() : size(0), capacity(2), data((int *)malloc(capacity * sizeof(int))) {
        if (data == nullptr) {
            std::cerr << "memory failed" << std::endl;
            throw std::bad_alloc{};
        }
    }

    ~dynamicArray() {
        free(data);
    }

    void add(int val) {
        if (size == capacity) {
            resize(capacity * 2);
        }
        *(data + size) = val;
        size++;
    }

    int get(size_t index) {
        if (index >= size)
            throw std::out_of_range{"index out of range"};
        return data[index];
    }

    size_t getsize() {
        return size;
    }
};
```

---

## ç®€å•è®¤è¯†å†…å­˜æ± 

```cpp
#include <iostream>
#include <stack>
#include <string>

class Student {
public:
    int id;
    std::string name;
    Student(int a, std::string name) : id(a), name(name) {}
};

class memoryPool {
    size_t objsize;
    size_t totalsize;
    char *pool;
    std::stack<void *> freelist;

public:
    memoryPool(size_t objsize, size_t total) : objsize(objsize), totalsize(total) {
        pool = (char *)malloc(objsize * totalsize);
        if (pool == nullptr)
            throw std::bad_alloc();
        for (size_t i = 0; i < totalsize; i++) {
            freelist.push(pool + i * objsize);
        }
    }

    ~memoryPool() {
        free(pool);
        std::cout << "release";
    }

    void *allocate() {
        if (freelist.empty())
            throw std::bad_alloc();
        void *p = freelist.top();
        freelist.pop();
        return p;
    }

    void deallocate(void *p) {
        freelist.push(p);
    }
};

int main() {
    try {
        memoryPool pool(sizeof(Student), 3);
        void *p1 = pool.allocate();
        void *p2 = pool.allocate();
        void *p3 = pool.allocate();

        // placement new
        Student *s1 = new (p1) Student(20, "Tom");
        Student *s2 = new (p2) Student(34, "Jim");

        std::cout << s2->id << ' ' << s2->name << std::endl;
        std::cout << s1->id << ' ' << s1->name << std::endl;

        // void *p4 = pool.allocate();  // ä¼šæŠ›å‡ºå¼‚å¸¸

        // æ˜¾å¼è°ƒç”¨ææ„å‡½æ•°
        s1->~Student();
        s2->~Student();

        pool.deallocate(p1);
        pool.deallocate(p2);
    }
    catch (const std::out_of_range &e) {
        std::cerr << "array access error" << e.what() << std::endl;
        return -1;
    }
    catch (const std::bad_alloc &e) {
        std::cerr << "memory failed" << e.what() << std::endl;
        return -1;
    }
    catch (const std::exception &e) {
        std::cerr << "error" << e.what() << std::endl;
        return -1;
    }

    return 0;
}
```

---

## é¿å…å†…å­˜æ³„æ¼

ç¡®ä¿ `new` ä¸ `delete` é…å¯¹å­˜åœ¨ï¼Œä½¿ç”¨ RAII ä¸æ™ºèƒ½æŒ‡é’ˆï¼Œä½¿ç”¨ Valgrind æ£€æµ‹å†…å­˜æ³„æ¼ã€‚

---

## æ™ºèƒ½æŒ‡é’ˆ

### unique_ptr

**åªèƒ½ç»‘å®šä¸€ä¸ªå¯¹è±¡**ï¼Œä¸å­˜åœ¨èµ‹å€¼æ“ä½œï¼Œåªèƒ½é€šè¿‡ `std::move()` æ¥ä¼ é€’ï¼Œæ„é€ æ—¶å¯ä»¥ç›´æ¥ä¼ è£¸æŒ‡é’ˆã€‚

```cpp
std::unique_ptr<Student> ptr = std::make_unique<Student>(20, "tim");
std::unique_ptr<Student> p(new Student(12, "jim"));
std::unique_ptr<Student> ptr2 = std::move(p);
// std::unique_ptr<Student> ptr2 = p;  // é”™è¯¯çš„
```

### shared_ptr

**å¤šå¯¹ä¸€çš„å­˜åœ¨**ï¼Œæœ‰ control block æ§åˆ¶ä½¿ç”¨æ•°é‡ï¼Œé¿å…å‡ºç°æ‚¬ç©ºæŒ‡é’ˆçš„æƒ…å†µã€‚

æœ‰ `use_count` ç»Ÿè®¡å¼ºå¼•ç”¨ï¼Œ`weak_count` ç»Ÿè®¡å¼±å¼•ç”¨ã€‚

```cpp
std::shared_ptr<Student> ptr = std::make_shared<Student>(20, "tim");
std::shared_ptr<Student> p(new Student(12, "jim"));
std::shared_ptr<Student> ptr2 = p;
std::shared_ptr<Student> ptr2 = std::move(p);
```

### weak_ptr

**é€‚ç”¨äºé¿å…å¾ªç¯å¼•ç”¨**ï¼ˆå­˜åœ¨åŒå‘å…³è”ï¼Œå¦‚çˆ¶å­å…³ç³»ï¼‰ï¼Œå¯ä»¥é€šè¿‡å…¶è®¿é—® shared_ptr ç®¡ç†çš„å¯¹è±¡ï¼ˆä½¿ç”¨ `lock()` å‡½æ•°ï¼‰ï¼›`bool expired()` åˆ¤æ–­å½“å‰æ‰€æŒ‡å¯¹è±¡æ˜¯å¦å·²è¢«å›æ”¶ã€‚

**å¾ªç¯å¼•ç”¨ç¤ºä¾‹ï¼š**

```cpp
class B;
class A {
public:
    std::shared_ptr<B> ptr_b;
    A() { std::cout << "A()" << std::endl; }
    ~A() { std::cout << "~A()" << std::endl; }
};

class B {
public:
    std::shared_ptr<A> ptr_a;  // æ”¹ä¸º weak_ptr è§£å†³å¾ªç¯å¼•ç”¨
    B() { std::cout << "B()" << std::endl; }
    ~B() { std::cout << "~B()" << std::endl; }
};

std::shared_ptr<A> a = std::make_shared<A>();
std::shared_ptr<B> b = std::make_shared<B>();
a->ptr_b = b;
b->ptr_a = a;
// å†…å­˜æ³„æ¼ï¼Œæ²¡æœ‰è°ƒç”¨ Aã€B çš„ææ„å‡½æ•°
```

---

## å°ç»ƒä¹ 

```cpp
#include <iostream>
#include <memory>

class ResourcesManager {
    std::unique_ptr<int> ps;

public:
    ResourcesManager(int val) {
        ps = std::make_unique<int>(val);
    }

    int getValue() const {
        return *ps;
    }

    void setValue(int newValue) {
        *ps = newValue;
    }

    ResourcesManager(const ResourcesManager &other) = delete;
    ResourcesManager &operator=(const ResourcesManager &other) = delete;

    ResourcesManager(ResourcesManager &&other) noexcept {
        ps = std::move(other.ps);
        other.ps = nullptr;
    }

    ResourcesManager &operator=(ResourcesManager &&other) {
        if (this != &other) {
            ps = std::move(other.ps);
            other.ps = nullptr;
        }
        return *this;
    }
};

int main() {
    ResourcesManager a(10);
    std::cout << a.getValue() << std::endl;
    a.setValue(20);
    std::cout << a.getValue() << std::endl;
    ResourcesManager b(std::move(a));
    std::cout << b.getValue() << std::endl;
    return 0;
}
```

---

> æ•´ç†è€…ï¼šè•¾å§† ğŸ’™
